//// kgsws' DOOM2 ACE engine
// Second stage loader.

// Stuff to free, in this order:
// 'stdin' buffer - might be NULL; stdin @ 0x0001F578 (also clear 0x1F580)
// 'lumpcache' @ 0x00074F94
// 'lumpinfo' @ 0x00074FA4
// 'mainzone' @ 0x00074FE0

#define code_lump_info	0x0005A210

#define _memcpy	0x44070
#define _memset	0x3FE70
#define _free	0x4066D
#define _CheckNumForName	0x38AF0
#define _printf	0x3FE40
#define _read	0x40935
#define _lseek	0x408C0
#define _close	0x40902
#define _malloc	0x40602

#define _stdin	0x1F578
#define _lumpcache	0x74F94
#define _lumpinfo	0x74FA4
#define _mainzone	0x74FE0
#define _numlumps	0x74FA0
#define _vissprites	0x5A210
#define _drawsegs	0x2D0A0
#define _mainzone	0x74FE0

.section .text
.globl _start

_start:

	// entered second stage
	lea	text_info(%edi),%ebp
	push	%ebp
	lea	_printf(%esi),%ebp
	call	*%ebp
	pop	%eax

	//
	// backup zone size
	mov	_mainzone(%edi),%eax
	mov	(%eax),%eax
	mov	%eax, _drawsegs(%edi)

	//
	// copy engine lump info

	// find engine code
	lea	text_lump(%edi),%eax
	lea	_CheckNumForName(%esi),%ebp
	call	*%ebp

	// check
	test	%eax,%eax
	jns	do_clean

	// error message
	lea	text_error(%edi),%ebp
	push	%ebp
	lea	text_newline(%edi),%ebp
	push	%ebp
	lea	_printf(%esi),%ebp
	call	*%ebp

	// exit to DOS
	mov	$0x4c01,%ax
	int	$0x21

do_clean:

	// info text
	push	%eax
	lea	text_lump(%edi),%ebp
	push	%ebp
	lea	text_idx(%edi),%ebp
	push	%ebp
	lea	_printf(%esi),%ebp
	call	*%ebp
	pop	%eax
	pop	%eax
	pop	%eax

	// get engine lump info
	mov	$20,%edx
	imul	%edx
	add	_lumpinfo(%edi),%eax
	add	$8,%eax	// skip name

	// copy info
	mov	%eax,%edx
	lea	_vissprites(%edi),%eax
	mov	$12,%ebx
	lea	_memcpy(%esi),%ebp
	call	*%ebp

	//
	// copy open WAD file descriptors

	// info text
	mov	_mainzone(%edi),%ebp
	push	%ebp
	lea	text_cleanup(%edi),%ebp
	push	%ebp
	lea	_printf(%esi),%ebp
	call	*%ebp
	pop	%eax
	pop	%eax

	// lumpinfo->fd
	mov	_lumpinfo(%edi),%ebx
	add	$8,%ebx

	// lump info end ptr
	mov	_numlumps(%edi),%eax
	mov	$20,%edx
	imul	%edx
	add	%ebx,%eax

	// descriptor check
	xor	%edx,%edx
	dec	%edx

	// destination
	lea	_drawsegs+8(%edi),%ebp

	// the loop
_li_loop:
	// get file descriptor
	mov	(%ebx),%ecx
	cmp	%edx,%ecx
	je	_li_skip
	// descriptor changed, save it
	mov	%ecx,%edx
	mov	%ecx,(%ebp)
	add	$4,%ebp
_li_skip:
	// next
	add	$20,%ebx
	cmp	%eax,%ebx
	jl	_li_loop

	// terminate with invalid descriptor
	xor	%eax,%eax
	dec	%eax
	mov	%eax,(%ebp)

	//
	// free all the stuff

	// char buffer of stdin - might be empty
	mov	_stdin(%edi),%eax
	test	%eax,%eax
	jz	skip_stdin

	// free the buffer
	call	free

	// meset file buffer
	mov	$16,%ebx
	xor	%edx,%edx
	lea	_stdin(%edi),%eax
	lea	_memset(%esi),%ebp
	call	*%ebp

skip_stdin:

	// lumpcache
	mov	_lumpcache(%edi),%eax
	call	free

	// lumpinfo
	mov	_lumpinfo(%edi),%eax
	call	free

	// mainzone
	mov	_mainzone(%edi),%eax
	call	free

	//
	// load the code

	// get FD
	mov	_vissprites(%edi),%ecx

	// seek
	mov	%ecx,%eax
	mov	_vissprites+4(%edi),%edx
	xor	%ebx,%ebx
	lea	_lseek(%esi),%ebp
	call	*%ebp

	// read .bss size (4B)
	mov	%ecx,%eax
	lea	_drawsegs+4(%edi),%edx
	mov	$4,%ebx
	lea	_read(%esi),%ebp
	call	*%ebp

	// calculate memory size
	mov	_drawsegs+4(%edi),%eax
	add	_vissprites+8(%edi),%eax
	add	$32,%eax

	// allocate memory
	lea	_malloc(%esi),%ebp
	call	*%ebp
	test	%eax,%eax
	jnz	do_load

	// error message
	lea	text_memory(%edi),%ebp
	push	%ebp
	lea	_printf(%esi),%ebp
	call	*%ebp

	// exit to DOS
	mov	$0x4c01,%ax
	int	$0x21

	//
	// read the code
do_load:

	// skip uint32_t (.bss size)
	add	$4,%eax

	// read all
	mov	%eax,%edx
	xchg	%ecx,%eax
	mov	_vissprites+8(%edi),%ebx
	sub	$4,%ebx
	lea	_read(%esi),%ebp
	call	*%ebp

	//
	// close all WAD files

	// descriptor list
	lea	_drawsegs+8(%edi),%edx

	// terminator
	xor	%ebx,%ebx
	dec	%ebx

	// the loop
_cl_loop:
	mov	(%edx),%eax

	cmp	%eax,%ebx
	jz	do_start
	lea	_close(%esi),%ebp
	call	*%ebp
	add	$4,%edx
	jmp	_cl_loop

do_start:
	// info text
	lea	-4(%ecx),%eax
	push	%eax
	lea	text_ace(%edi),%ebp
	push	%ebp
	lea	_printf(%esi),%ebp
	call	*%ebp
	pop	%eax
	pop	%eax

	//
	// jump to to the code
	// EDI = DATA base
	// ESI = CODE base
	// ECX = ACE base
	jmp	*%ecx

//
// functions

free:
	lea	_free(%esi),%ebp
	call	*%ebp
	ret

//
// text

text_info:
	.string	"- second stage\n"

text_cleanup:
	.string	"- zone 0x%08X\n- cleaning up\n"

text_ace:
	.string	"- memory 0x%08X\n"

text_memory:
	.string	"- allocation failed\n"

text_error:
	.ascii	"- missing " // fall trough to 'text_lump'

text_lump:
	.string	"ACE_CODE"

text_newline:
	.string	"%s!\n"

text_idx:
	.string	"- %s lump %u\n"

